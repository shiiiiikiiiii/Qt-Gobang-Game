
**数据结构课程设计报告**


`              `-------基于C++和Qt6.0的五子棋人机对弈系统



`        `软件学院

姓名：    学号：


任课教师：      实验教师：     助教：






目 录

[一、	系统开发平台	1]()

[1.1题目: 简易五子棋游戏	1]()

[1.2开发工具	1]()

[1.3操作系统	1]()

[1.4编译器	1]()

[二、	系统规划	1]()

[2.1 任务陈述	1]()

[2.2 任务目标	2]()

[三、	系统定义	2]()

[四、	需求分析	2]()

[4.1 用户需求说明	2]()

[4.1.1 数据结构需求	2]()

[4.1.2 操作需求	2]()

[4.1.3界面需求	2]()

[4.2 系统需求说明	3]()

[五、	数据结构设计	3]()

[5.1 逻辑结构及操作设计	3]()

[5.2 存储结构	3]()

[六、	算法设计	3]()

[6.1 DFS算法判断胜者	3]()

[6.2 朴素遍历算法给棋盘打分	4]()

[6.3 界面设计	6]()

[七、	测试和运行	6]()

[八、	总结	6]()

[九、	参考文献	7]()

[程序清单	7]()


i

1. # **系统开发平台**
## **1.1题目: 简易五子棋游戏**
设计程序实现一个人机对弈的简单的五子棋游戏。游戏规则如下：在19×19的围棋交叉点上，对弈双方轮流放子，最先在棋盘上摆成（按照水平、垂直或者对角线方向）连续五个子的一方为胜方。
## **1.2开发工具**
Qt Creator 是一款跨平台的集成开发环境，特别针对Qt开发者，是Qt SDK组成的一部分，可运行于Windows、Linux及Mac OS X等操作系统，允许开发者为多桌面环境及移动设备平台创建应用程序。它包括一个可视化调试工具和集成的 GUI 版面和外形设计师。这个编辑器的功能包括语法高亮度显示和自动完成。Qt Creator 在 Linux 上，使用 GCC 的 C++ 编译器。在 Windows，默认安装它可以使用 MinGW 或 MSVC。从源代码编译时，也可以使用 cdb。[1]

使用版本为Qt6.0。
## **1.3操作系统**
使用Windows10操作系统开发。
### **1.4编译器**
编译器使用MinGW, Qt自带。
1. # **系统规划**
## **2.1 任务陈述**
第一部分是五子棋应用程序的基础：第一是要实现五子棋的棋盘；第二是要实现黑白五子棋在棋盘上轮流落子；第三是要实现五颗棋连珠时的胜负判断。

第二部分是ai下五子棋的判断：ai根据目前场上的局势来综合打分，决定自己下一步落子的位置。

第三部分是系统GUI的设计：主要设计了棋盘和棋子的绘制，还有胜负判断弹窗，和几个调用悔棋、重开等算法的按钮。
## **2.2 任务目标**
棋盘

下棋

胜负判断

AI

屏幕输出

维护（构造、更新、插入和删除）堆

维护（构造、更新、插入和删除）栈

实现对更新过程中数据交换的展示

在五六节中详细讨论
1. # **系统定义**
基于C++和Qt6.0的五子棋对弈系统，设计了AI对弈机制并可以在任意一步决定是否调用AI。
1. # **需求分析**
## **4.1 用户需求说明**
### **4.1.1 数据结构需求**
- **在X中，包含了哪些数据？**
- **你要对X做哪些操作？**

**如：在霍夫曼编码情况中，你要包含哪些数据？对该数据做哪些操作？**

**需要包含权重。我要录入各字母的权重情况，创建单个元素的霍夫曼树、在单步过程中比较权值的大小，合并霍夫曼树，输出完整的霍夫曼树及各字符的编码。**

- **需要什么样的结构来满足这些数据及数据的操作？**

\1. 一个19\*19的邻接矩阵，用int类型-1，0，1分别代表白棋，无棋子，黑棋

\2. 一个栈，用来实现悔棋

\3. 一个bool类型变量，用来判断下一步是黑棋还是白棋
### **4.1.2 操作需求**
每次启动mainwindow的时候new一个新的chessboard类。
### **4.1.3界面需求**
主题是绘图函数绘制的棋盘和棋子。

另外安排的还有三个按钮，分别调用AI下棋，悔棋和重开的函数。
## **4.2 系统需求说明** 	
关键事务是胜负判断

内存和算力的要求都很低
1. # **数据结构设计**
## **5.1 逻辑结构及操作设计**
棋盘是一个19\*19节点的图

悔棋用到了栈
## **5.2 存储结构**
用int型二维数组存储，邻接矩阵表示图

用STL库的<stack>
1. # **算法设计**
## **6.1 DFS算法判断胜者**
用DFS向八个方向遍历[2]

bool chessboard::**DFS**(int x,int y,int count,int id,int dir){

`    `//方向向量:上,右上,右,右下,下,左下,左,左上

`    `int dirVector[8][2]={{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1}};

`    `//DFS

`    `if(count>=5) return true;//退出条件

`    `else

`        `//棋子同种则继续递归

`        `if(getChess(x,y)==id)

`            `return DFS(x+dirVector[dir][0],y+dirVector[dir][1],count+1,id,dir);

`        `else return false;

}

int chessboard::**winner**(int x,int y){

`    `//往八个方向DFS

`    `for(int i=0;i<8;i++){

`        `if( DFS(x,y,0,getChess(x,y),i) )

`            `return getChess(x,y);

`    `}

`    `return -2;

}

## **6.2 朴素遍历算法给棋盘打分**
朴素遍历示意图


根据棋盘分布打分的算法[3]

`                            `// 对玩家子评分

`                            `if (personNum == 1)                      // 杀二

`                                `scoreMapVec[row][col] += 10;

`                            `else if (personNum == 2)                 // 杀三

`                            `{

`                                `if (emptyNum == 1)

`                                    `scoreMapVec[row][col] += 30;

`                                `else if (emptyNum == 2)

`                                    `scoreMapVec[row][col] += 40;

`                            `}

`                            `else if (personNum == 3)                 // 杀四

`                            `{

`                                `// 量变空位不一样，优先级不一样

`                                `if (emptyNum == 1)

`                                    `scoreMapVec[row][col] += 60;

`                                `else if (emptyNum == 2)

`                                    `scoreMapVec[row][col] += 110;

`                            `}

`                            `else if (personNum == 4)                 // 杀五

`                                `scoreMapVec[row][col] += 10100;





`                            `// 对AI子评分

`                            `if (botNum == 0)                      // 普通下子

`                                `scoreMapVec[row][col] += 5;

`                            `else if (botNum == 1)                 // 活二

`                                `scoreMapVec[row][col] += 10;

`                            `else if (botNum == 2)

`                            `{

`                                `if (emptyNum == 1)                // 死三

`                                    `scoreMapVec[row][col] += 25;

`                                `else if (emptyNum == 2)

`                                    `scoreMapVec[row][col] += 50;  // 活三

`                            `}

`                            `else if (botNum == 3)

`                            `{

`                                `if (emptyNum == 1)                // 死四

`                                    `scoreMapVec[row][col] += 55;

`                                `else if (emptyNum == 2)

`                                    `scoreMapVec[row][col] += 100; // 活四

`                            `}

`                            `else if (botNum >= 4)

`                                `scoreMapVec[row][col] += 10000;   // 活五
## **6.3 界面设计**

左边绿色线画棋盘[4],右边摆放了三个按钮
1. # **测试和运行**
(1)竖着连五         (2)横着连五             (3)斜着连五             (4)连六

1. # **总结**
学习了用Qt开发C++的GUI程序

学习了把图的算法（DFS、朴素遍历）应用到实践中
1. # **参考文献**
[1] 维基百科编者. Qt Creator[G/OL]. 维基百科, 2022(20220212)[2022-02-12]. [https://zh.wikipedia.org/w/index.php?title=Qt_Creator&oldid=70133148]().

[2] 2020-SWU-CS-学年设计. (2020, August 1). Retrieved from gitee: [https://gitee.com/sunist/Project-2020]()

[3] FiveChessGame. (2020, July 25). Retrieved from github: https://github.com/fuxiai/FiveChessGame

[3] Qt中绘制五子棋棋盘. (2017, April 1). Retrieved from csdn: https://blog.csdn.net/u011579908/article/details/68943521
# **程序清单**
见文件夹中所附源代码
4

